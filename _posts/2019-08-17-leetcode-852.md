---
layout:     post
title:      [Leetcode Solutions in Python] #852 - Peak index in a mountain array
subtitle:   "\"Posting Test\""
date:       2019-08-17
author:     XL
header-img: img/post-bd-coding.png
catalog: 	 true
tags:
    - Python
    - Leetcode
    - Programming
---

# Problem: 
 
## Peak index in a mountain array

Let's call an array *A* a mountain if the following properties hold:

- *A.length >= 3* 
- There exists some *0 < i < A.length - 1* such that *A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]*

Given an array that is definitely a mountain, return any *i* such that *A[0] < A[1] < … A[i-1] < A[i] > A[i+1] > … > A[A.length - 1]*.

**Example 1**:

    Input: [0,1,0]
    Output:  1

**Example 2**:

    Input: [0,2,1,0]
    Output:  1

**Note:**

    1. 3 <= A.length <= 10000
    2. 0 <= A[i] <= 10^6
    3. A is a mountain, as defined above.

# Solutions
- Solution 1, basic idea
    - Time complexity is *O(N)*

```python
class Solution:
	def peakIndexInMountainArray(self, A):
		"""
		:type A: List[int]
		:rtype: int
		"""
		return A.index(max(A))

```

- Solution 2, using binary search
    - Time complexity is *O(log(N))*

```python
class Solution:
	def peakIndexInMountainArray(self, A):
		"""
		:type A; List[int]
		:rtype: int
		"""
		low, hight = 0, len(A) - 1
		while low <= high:
			mid = (low + high) // 2
			if A[mid] > A[mid-1] and A[mid] > A[mid+1]:
				return mid
			if A[mid-1] < A[mid] < A[mid+1]:
				low = mid + 1
			if A[mid-1] > A[mid] > A[mid+1]:
				high = mid - 1

```